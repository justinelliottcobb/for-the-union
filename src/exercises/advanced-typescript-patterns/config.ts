import type { ExerciseCategory } from '@/types';

export const advancedTypeScriptPatternsCategory: ExerciseCategory = {
  id: 'advanced-typescript-patterns',
  name: 'Advanced TypeScript Patterns',
  description: 'Master the most sophisticated TypeScript patterns and category theory concepts',
  icon: 'IconCode',
  order: 4,
  exercises: [
    {
      id: '01-higher-kinded-types',
      title: 'Higher-Kinded Types and Type Constructors',
      description: 'Master abstract type programming by abstracting over type constructors',
      category: 'advanced-typescript-patterns',
      difficulty: 5,
      prerequisites: [],
      learningObjectives: [
        'Understand the difference between types and type constructors',
        'Implement Higher-Kinded Types using branded types and module augmentation',
        'Create generic abstractions that work across different container types',
        'Build type-level functions that operate on type constructors',
        'Implement kind-polymorphic functions and data structures',
        'Design APIs that are parametric in their container type',
      ],
      hints: [
        'TypeScript doesn\'t have native HKT support, but we can simulate it with clever type programming',
        'Use module augmentation to register type constructors in a global registry',
        'Branded types help us distinguish between different kinds at the type level',
        'Think in terms of "containers" and "contained values" - abstract over the container',
        'HKT allows us to write code once that works for Maybe, Either, Array, IO, etc.',
        'Focus on the "shape" of computation, not the specific container',
      ],
      estimatedTime: 60,
      filePath: './exercise-files/advanced-typescript-patterns/01-higher-kinded-types/exercise.ts',
      solutionPath: './src/exercises/advanced-typescript-patterns/01-higher-kinded-types/solution.tsx',
      testsPath: './src/exercises/advanced-typescript-patterns/01-higher-kinded-types/tests.ts',
      instructionsPath: './src/exercises/advanced-typescript-patterns/01-higher-kinded-types/instructions.md',
    },
    {
      id: '02-phantom-types',
      title: 'Phantom Types and Compile-time Safety',
      description: 'Zero-runtime-cost type-level constraints and invariants',
      category: 'advanced-typescript-patterns',
      difficulty: 4,
      prerequisites: ['01-higher-kinded-types'],
      learningObjectives: [
        'Understand phantom types and zero-runtime-cost safety',
        'Implement state machines with phantom states',
        'Create units of measure preventing calculation errors',
        'Design database connection lifecycle with phantom states',
        'Build HTTP request builders ensuring required fields',
        'Create branded primitives preventing type mix-ups',
      ],
      hints: [
        'Phantom types exist only at compile time - no runtime overhead',
        'Use branded types with never-existing properties',
        'State machines can prevent invalid state transitions at compile time',
        'Units of measure prevent Mars Climate Orbiter disasters',
        'Builder patterns can ensure all required fields are provided',
        'Branded primitives like UserId prevent accidental mixing',
      ],
      estimatedTime: 45,
      filePath: './exercise-files/advanced-typescript-patterns/02-phantom-types/exercise.tsx',
      solutionPath: './src/exercises/advanced-typescript-patterns/02-phantom-types/solution.tsx',
      testsPath: './src/exercises/advanced-typescript-patterns/02-phantom-types/tests.ts',
      instructionsPath: './src/exercises/advanced-typescript-patterns/02-phantom-types/instructions.md',
    },
    {
      id: '03-dependent-types',
      title: 'Dependent Types and Value-Level Types',
      description: 'Types that depend on values for compile-time safety',
      category: 'advanced-typescript-patterns',
      difficulty: 5,
      prerequisites: ['02-phantom-types'],
      learningObjectives: [
        'Understand dependent types and value-level type programming',
        'Implement length-indexed arrays with compile-time bounds checking',
        'Master type-level arithmetic operations',
        'Create refinement types with value constraints',
        'Use template literal programming for string manipulation',
        'Build type-safe configuration builders dependent on environment',
      ],
      hints: [
        'Dependent types let you encode invariants in the type system',
        'Length-indexed arrays prevent out-of-bounds errors at compile time',
        'Type-level arithmetic uses recursive conditional types',
        'Refinement types ensure values meet specific constraints',
        'Template literal types enable powerful string manipulations',
        'Environment-dependent configs ensure type safety across deployments',
      ],
      estimatedTime: 50,
      filePath: './exercise-files/advanced-typescript-patterns/03-dependent-types/exercise.tsx',
      solutionPath: './src/exercises/advanced-typescript-patterns/03-dependent-types/solution.tsx',
      testsPath: './src/exercises/advanced-typescript-patterns/03-dependent-types/tests.ts',
      instructionsPath: './src/exercises/advanced-typescript-patterns/03-dependent-types/instructions.md',
    },
    {
      id: '04-gadts-type-safe-state-machines',
      title: 'GADTs and Type-Safe State Machines',
      description: 'Generalized Algebraic Data Types for impossible-to-break state machines',
      category: 'advanced-typescript-patterns',
      difficulty: 5,
      prerequisites: ['03-dependent-types'],
      learningObjectives: [
        'Understand Generalized Algebraic Data Types extending regular ADTs',
        'Implement network connection state machines preventing invalid transitions',
        'Create document editing systems with undo/redo capabilities',
        'Build game state management with hierarchical states',
        'Model HTTP request lifecycles with type safety',
        'Design interactive React components with impossible-to-break state',
      ],
      hints: [
        'GADTs allow constructors to specify return types more precisely',
        'State machines can encode valid transitions at the type level',
        'Pattern matching reveals additional type information',
        'Impossible states become literally impossible to represent',
        'React components can leverage GADTs for bulletproof state management',
        'Use discriminated unions with type guards for GADT patterns',
      ],
      estimatedTime: 55,
      filePath: './exercise-files/advanced-typescript-patterns/04-gadts-type-safe-state-machines/exercise.tsx',
      solutionPath: './src/exercises/advanced-typescript-patterns/04-gadts-type-safe-state-machines/solution.tsx',
      testsPath: './src/exercises/advanced-typescript-patterns/04-gadts-type-safe-state-machines/tests.ts',
      instructionsPath: './src/exercises/advanced-typescript-patterns/04-gadts-type-safe-state-machines/instructions.md',
    },
    {
      id: '05-profunctors-variance-patterns',
      title: 'Profunctors and Variance Patterns',
      description: 'Master contravariant/covariant duality and optics',
      category: 'advanced-typescript-patterns',
      difficulty: 5,
      prerequisites: ['04-gadts-type-safe-state-machines'],
      learningObjectives: [
        'Understand contravariant/covariant duality principles',
        'Implement Function, Tagged, Star, Forget profunctors',
        'Master Strong profunctors for handling product types',
        'Use Choice profunctors for handling sum types',
        'Create Optics (Lenses) using profunctor encoding',
        'Build data transformation pipelines and parser combinators',
      ],
      hints: [
        'Profunctors are contravariant in first argument, covariant in second',
        'Strong profunctors can handle tuples and records',
        'Choice profunctors can handle Either and union types',
        'Lenses are just profunctor-encoded data accessors',
        'Parser combinators naturally form profunctor structures',
        'Think of profunctors as "shape-preserving transformations"',
      ],
      estimatedTime: 65,
      filePath: './exercise-files/advanced-typescript-patterns/05-profunctors-variance-patterns/exercise.tsx',
      solutionPath: './src/exercises/advanced-typescript-patterns/05-profunctors-variance-patterns/solution.tsx',
      testsPath: './src/exercises/advanced-typescript-patterns/05-profunctors-variance-patterns/tests.ts',
      instructionsPath: './src/exercises/advanced-typescript-patterns/05-profunctors-variance-patterns/instructions.md',
    },
    {
      id: '06-free-monads-abstract-computation',
      title: 'Free Monads and Abstract Computation',
      description: 'Revolutionary separation of program structure from interpretation',
      category: 'advanced-typescript-patterns',
      difficulty: 5,
      prerequisites: ['05-profunctors-variance-patterns'],
      learningObjectives: [
        'Understand revolutionary separation of structure from interpretation',
        'Create Console, HTTP, State, Logging DSLs with multiple interpreters',
        'Implement Pure, Interactive, Mock interpreters for different contexts',
        'Master program composition using flatMap for sequential execution',
        'Handle effect stacking and algebraic effects',
        'Transform programs as data structures',
      ],
      hints: [
        'Free monads separate "what to do" from "how to do it"',
        'Programs become data structures that can be inspected and transformed',
        'Different interpreters can run the same program in different contexts',
        'Pure interpreters enable deterministic testing',
        'Interactive interpreters connect to real UI and services',
        'Think of programs as abstract syntax trees',
      ],
      estimatedTime: 70,
      filePath: './exercise-files/advanced-typescript-patterns/06-free-monads-abstract-computation/exercise.tsx',
      solutionPath: './src/exercises/advanced-typescript-patterns/06-free-monads-abstract-computation/solution.tsx',
      testsPath: './src/exercises/advanced-typescript-patterns/06-free-monads-abstract-computation/tests.ts',
      instructionsPath: './src/exercises/advanced-typescript-patterns/06-free-monads-abstract-computation/instructions.md',
    },
    {
      id: '07-type-level-computation-meta-programming',
      title: 'Type-Level Computation and Meta-Programming',
      description: 'Turing-complete type system programming with zero runtime cost',
      category: 'advanced-typescript-patterns',
      difficulty: 5,
      prerequisites: ['06-free-monads-abstract-computation'],
      learningObjectives: [
        'Master Turing-complete type system for compile-time computation',
        'Implement type-level quicksort and arithmetic operations',
        'Create template literal parsers and string manipulation',
        'Build database schema validation at compile time',
        'Generate TypeScript interfaces from JSON Schema',
        'Achieve zero runtime cost through compile-time computation',
      ],
      hints: [
        'TypeScript\'s type system is Turing-complete',
        'Recursive conditional types enable complex computations',
        'Template literal types are powerful string processors',
        'Type-level algorithms run only during compilation',
        'Mapped types and conditional types are the building blocks',
        'Complex computations can be cached using type aliases',
      ],
      estimatedTime: 65,
      filePath: './exercise-files/advanced-typescript-patterns/07-type-level-computation-meta-programming/exercise.tsx',
      solutionPath: './src/exercises/advanced-typescript-patterns/07-type-level-computation-meta-programming/solution.tsx',
      testsPath: './src/exercises/advanced-typescript-patterns/07-type-level-computation-meta-programming/tests.ts',
      instructionsPath: './src/exercises/advanced-typescript-patterns/07-type-level-computation-meta-programming/instructions.md',
    },
    {
      id: '08-category-theory-foundations',
      title: 'Category Theory Foundations',
      description: 'The mathematical foundation uniting all patterns',
      category: 'advanced-typescript-patterns',
      difficulty: 5,
      prerequisites: ['07-type-level-computation-meta-programming'],
      learningObjectives: [
        'Understand the mathematical foundation uniting all patterns',
        'Master Categories, Objects, Morphisms with law verification',
        'Implement Functors, Natural Transformations, structure preservation',
        'Create Monoids, Semigroups with algebraic operations',
        'Distinguish Applicative vs Monad (parallel vs sequential)',
        'Explore Comonads and context extraction',
        'Study Adjunctions and Yoneda embedding',
      ],
      hints: [
        'Category theory provides the unified mathematical foundation',
        'Laws are more important than implementations',
        'Functors preserve structure and composition',
        'Natural transformations are "structure-preserving mappings between functors"',
        'Monoids have identity and associativity laws',
        'Applicatives enable parallel computation, Monads enable sequential',
        'Interactive law verification shows mathematical principles in action',
      ],
      estimatedTime: 75,
      filePath: './exercise-files/advanced-typescript-patterns/08-category-theory-foundations/exercise.tsx',
      solutionPath: './src/exercises/advanced-typescript-patterns/08-category-theory-foundations/solution.tsx',
      testsPath: './src/exercises/advanced-typescript-patterns/08-category-theory-foundations/tests.ts',
      instructionsPath: './src/exercises/advanced-typescript-patterns/08-category-theory-foundations/instructions.md',
    },
  ],
};